doVAR R> EXIT
UP doVAR UPP
+ UM+ DROP EXIT
doUSER R> @ UP @ + EXIT

$USER CP
$USER NP
$USER SP0
$USER RP0
$USER #TIB
$USER
$USER HLD
$USER BASE
$USER tmp
$USER >IN
$USER CONTEXT
$USER
$USER
$USER
$USER
$USER
$USER
$USER
$USER
$USER CURRENT
$USER
$USER SPAN
$USER HANDLER
$USER 'EVAL
$USER 'NUMBER
$USER 'EMIT
$USER 'EXPECT
$USER 'TAP
$USER 'ECHO
$USER 'PROMPT

doVOC R> CONTEXT ! EXIT
FORTH doVOC 0 0
?DUP DUP ?branch QDUP1 DUP QDUP1: EXIT
ROT >R SWAP R> SWAP EXIT
2DROP DROP DROP EXIT
2DUP OVER OVER EXIT
D+ >R SWAP >R UM+ R> R> + + EXIT
NOT doLIT -1 XOR EXIT
NEGATE NOT doLIT 1 + EXIT
DNEGATE NOT >R NOT doLIT 1 UM+ R> + EXIT
- NEGATE + EXIT
ABS DUP 0< ?branch ABS1 NEGATE ABS1: EXIT
= XOR ?branch EQU1 doLIT 0 EXIT EQU1: doLIT -1 EXIT
U< 2DUP XOR 0< ?branch ULES1 SWAP DROP 0< EXIT ULES1: - 0< EXIT
< 2DUP XOR 0< ?branch LESS1 DROP 0< EXIT LESS1: - 0< EXIT
MAX 2DUP < ?branch MAX1 SWAP MAX1: DROP EXIT
MIN 2DUP SWAP < ?branch MIN1 SWAP MIN1: DROP EXIT
WITHIN OVER - >R - R> U< EXIT

UM/MOD 2DUP U< ?branch UMM4 NEGATE doLIT 15 >R UMM1: >R DUP UM+ >R >R DUP UM+ R> + DUP R> R@ SWAP >R UM+ R> OR ?branch UMM2 >R DROP doLIT 1 + R> branch UMM3 UMM2: DROP UMM3: R> next UMM1 DROP SWAP EXIT UMM4: DROP 2DROP doLIT -1 DUP EXIT
M/MOD DUP 0< DUP >R ?branch MMOD1 NEGATE >R DNEGATE R> MMOD1: >R DUP 0< ?branch MMOD2 R@ + MMOD2: R> UM/MOD R> ?branch MMOD3 SWAP NEGATE SWAP MMOD3: EXIT
/MOD OVER 0< SWAP M/MOD EXIT
MOD /MOD DROP EXIT
/ /MOD SWAP DROP EXIT

UM* doLIT 0 SWAP doLIT 15 >R UMST1: DUP UM+ >R >R DUP UM+ R> + R> ?branch UMST2 >R OVER UM+ R> + UMST2: next UMST1 ROT DROP EXIT
* UM* DROP EXIT
M* 2DUP XOR 0< >R ABS SWAP ABS UM* R> ?branch MSTA1 DNEGATE MSTA1: EXIT
*/MOD >R M* R> M/MOD EXIT
*/ */MOD SWAP DROP EXIT

CELL+ doLIT CELLL + EXIT
CELL- doLIT CELLL - EXIT
CELLS doLIT CELLL * EXIT
ALIGNED DUP doLIT 0 doLIT CELLL UM/MOD DROP DUP ?branch ALGN1 doLIT CELLL SWAP - ALGN1: + EXIT
BL doLIT 32 EXIT
>CHAR doLIT 127 AND DUP doLIT 127 BL WITHIN ?branch TCHA1 DROP doLIT 95 TCHA1: EXIT
DEPTH SP@ SP0 @ SWAP - doLIT CELLL / EXIT
PICK doLIT 1 + CELLS SP@ + @ EXIT

+! SWAP OVER @ + SWAP ! EXIT
2! SWAP OVER ! CELL+ ! EXIT
2@ DUP CELL+ @ SWAP @ EXIT
COUNT DUP doLIT 1 + SWAP C@ EXIT
HERE CP @ EXIT
PAD HERE doLIT 80 + EXIT
TIB #TIB CELL+ @ EXIT
@EXECUTE @ ?DUP ?branch EXE1 EXECUTE EXE1: EXIT
CMOVE >R branch CMOV2 CMOV1: >R DUP C@ R@ C! doLIT 1 + R> doLIT 1 + CMOV2: next CMOV1 2DROP EXIT
FILL SWAP >R SWAP branch FILL2 FILL1: 2DUP C! doLIT 1 + FILL2: next FILL1 2DROP EXIT
PACK$ ALIGNED DUP >R OVER DUP doLIT 0 doLIT CELLL UM/MOD DROP - OVER + doLIT 0 SWAP ! 2DUP C! doLIT 1 + SWAP CMOVE R> EXIT

DIGIT doLIT 9 OVER < doLIT 7 AND + doLIT 48 + EXIT
EXTRACT doLIT 0 SWAP UM/MOD SWAP DIGIT EXIT
<# PAD HLD ! EXIT
HOLD HLD @ doLIT 1 - DUP HLD ! C! EXIT
# BASE @ EXTRACT HOLD EXIT
#S DIGS1: # DUP ?branch DIGS2 branch DIGS1 DIGS2: EXIT
SIGN 0< ?branch SIGN1 doLIT 45 HOLD SIGN1: EXIT
#> DROP HLD @ PAD OVER - EXIT
str DUP >R ABS <# #S R> SIGN #> EXIT
HEX doLIT 16 BASE ! EXIT
DECIMAL doLIT 10 BASE ! EXIT

DIGIT? >R doLIT 48 - doLIT 9 OVER < ?branch DGTQ1 doLIT 7 - DUP doLIT 10 < OR DGTQ1: DUP R> U< EXIT
NUMBER? BASE @ >R doLIT 0 OVER COUNT OVER C@ doLIT 36 = ?branch NUMQ1 HEX SWAP doLIT 1 + SWAP doLIT 1 - NUMQ1: OVER C@ doLIT 45 = >R SWAP R@ - SWAP R@ + ?DUP ?branch NUMQ6 doLIT 1 - >R NUMQ2: DUP >R C@ BASE @ DIGIT? ?branch NUMQ4 SWAP BASE @ * + R> doLIT 1 + next NUMQ2 R@ SWAP DROP ?branch NUMQ3 NEGATE NUMQ3: SWAP branch NUMQ5 NUMQ4: R> R> 2DROP 2DROP doLIT 0 NUMQ5: DUP NUMQ6: R> 2DROP R> BASE ! EXIT

EMIT TX! EXIT
NUF? KEY doLIT CRR = EXIT
SPACE BL EMIT EXIT
SPACES doLIT 0 MAX >R branch CHAR2 CHAR1: SPACE CHAR2: next CHAR1 EXIT
TYPE >R branch TYPE2 TYPE1: DUP C@ EMIT doLIT 1 + TYPE2: next TYPE1 DROP EXIT
CR doLIT CRR EMIT EXIT
do$ R> R@ R> COUNT + ALIGNED >R SWAP >R EXIT
$"| do$ EXIT
."| do$ COUNT TYPE EXIT
.R >R str R> OVER - SPACES TYPE EXIT
U.R >R <# #S #> R> OVER - SPACES TYPE EXIT
U. <# #S #> SPACE TYPE EXIT
. BASE @ doLIT 10 XOR ?branch DOT1 U. EXIT DOT1: str SPACE TYPE EXIT
? @ . EXIT

parse tmp ! OVER >R DUP ?branch PARS8 doLIT 1 - tmp @ BL = ?branch PARS3 >R PARS1: BL OVER C@ - 0< NOT ?branch PARS2 doLIT 1 + next PARS1 R> DROP doLIT 0 DUP EXIT PARS2: R> PARS3: OVER SWAP >R PARS4: tmp @ OVER C@ - tmp @ BL = ?branch PARS5 0< PARS5: ?branch PARS6 doLIT 1 + next PARS4 DUP >R branch PARS7 PARS6: R> DROP DUP doLIT 1 + >R PARS7: OVER - R> R> - EXIT PARS8: OVER R> - EXIT
PARSE >R TIB >IN @ + #TIB @ >IN @ - R> parse >IN +! EXIT
.( doLIT 41 PARSE TYPE EXIT
( doLIT 41 PARSE 2DROP EXIT
\ #TIB @ >IN ! EXIT
CHAR BL PARSE DROP C@ EXIT
TOKEN BL PARSE doLIT 31 MIN NP @ OVER - CELL- PACK$ EXIT
WORD PARSE HERE PACK$ EXIT

NAME> CELL- CELL- @ EXIT
SAME? >R branch SAME2 SAME1: OVER R@ CELLS + @ OVER R@ CELLS + @ - ?DUP ?branch SAME2 R> DROP EXIT SAME2: next SAME1 doLIT 0 EXIT
find SWAP DUP C@ doLIT CELLL / tmp ! DUP @ >R CELL+ SWAP FIND1: @ DUP ?branch FIND6 DUP @ doLIT MASKK AND R@ XOR ?branch FIND2 CELL+ doLIT -1 branch FIND3 FIND2: CELL+ tmp @ SAME? FIND3: branch FIND4 FIND6: R> DROP SWAP CELL- SWAP EXIT FIND4: ?branch FIND5 CELL- CELL- branch FIND1 FIND5: R> DROP SWAP DROP CELL- DUP NAME> SWAP EXIT
NAME? CONTEXT DUP 2@ XOR ?branch NAMQ1 CELL- NAMQ1: >R NAMQ2: R> CELL+ DUP >R @ ?DUP ?branch NAMQ3 find ?DUP ?branch NAMQ2 R> DROP EXIT NAMQ3: R> DROP doLIT 0 EXIT

^H >R OVER R> SWAP OVER XOR ?branch BACK1 doLIT BKSPP 'ECHO @EXECUTE doLIT 1 - BL 'ECHO @EXECUTE doLIT BKSPP 'ECHO @EXECUTE BACK1: EXIT
TAP DUP 'ECHO @EXECUTE OVER C! doLIT 1 + EXIT
kTAP DUP doLIT CRR XOR ?branch kTAP2 doLIT BKSPP XOR ?branch kTAP1 BL TAP EXIT kTAP1: ^H EXIT kTAP2: DROP SWAP DROP DUP EXIT
accept OVER + OVER ACCP1: 2DUP XOR ?branch ACCP4 KEY DUP BL doLIT 127 WITHIN ?branch ACCP2 TAP branch ACCP3 ACCP2: 'TAP @EXECUTE ACCP3: branch ACCP1 ACCP4: DROP OVER - EXIT
EXPECT 'EXPECT @EXECUTE SPAN ! DROP EXIT
QUERY TIB doLIT 80 'EXPECT @EXECUTE #TIB ! DROP doLIT 0 >IN ! EXIT

CATCH SP@ >R HANDLER @ >R RP@ HANDLER ! EXECUTE R> HANDLER ! R> DROP doLIT 0 EXIT
THROW HANDLER @ RP! R> HANDLER ! R> SWAP >R SP! DROP R> EXIT
NULL$ doVAR 0 BYTE 99 111 121 111 116 101 BYTE
ABORT NULL$ THROW
abort" ?branch ABQR1 do$ THROW ABQR1: do$ DROP EXIT

$INTERPRET NAME? ?DUP ?branch INTE1 @ doLIT COMPO AND abort" BYTE 13 32 99 111 109 112 105 108 101 32 111 110 108 121 BYTE EXECUTE EXIT INTE1: 'NUMBER @EXECUTE ?branch INTE2 EXIT INTE2: THROW
[ doLIT $INTERPRET 'EVAL ! EXIT
.OK doLIT $INTERPRET 'EVAL @ = ?branch DOTO1 ."| BYTE 3 32 79 75 BYTE DOTO1: CR EXIT
?STACK DEPTH 0< abort" BYTE 10 32 117 110 100 101 114 102 108 111 119 BYTE EXIT
EVAL EVAL1: TOKEN DUP C@ ?branch EVAL2 'EVAL @EXECUTE ?STACK branch EVAL1 EVAL2: DROP 'PROMPT @EXECUTE EXIT

PRESET SP0 @ SP! doLIT TIBB #TIB CELL+ ! EXIT
xio doLIT accept 'EXPECT 2! 'ECHO 2! EXIT
HAND doLIT .OK doLIT EMIT doLIT kTAP xio EXIT
CONSOLE doLIT EMIT 'EMIT ! HAND EXIT
COLD PRESET CONSOLE FORTH CONTEXT @ DUP CURRENT 2! EXIT
QUIT RP0 @ RP! QUIT1: [ QUIT2: QUERY doLIT EVAL CATCH ?DUP ?branch QUIT2 'PROMPT @ SWAP CONSOLE NULL$ OVER XOR ?branch QUIT3 SPACE COUNT TYPE ."| BYTE 3 32 ? 32 BYTE QUIT3: doLIT .OK XOR ?branch QUIT4 doLIT ERR EMIT QUIT4: PRESET branch QUIT1

STARTZ COLD STRT1: TIB doLIT 80 accept COUNT NAME? . . branch STRT1
STARTA COLD QUIT
START $"| BYTE 5 83 84 65 82 85 BYTE . CONTEXT . CURRENT . BYE
